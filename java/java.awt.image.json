{"entries": [{"type": "Interface", "name": "BufferedImageOp", "link": "BufferedImageOp"}, {"type": "Interface", "desc": "The interface for objects expressing interest in image data through the ImageProducer interfaces.", "name": "ImageConsumer", "link": "ImageConsumer"}, {"type": "Interface", "desc": "An asynchronous update interface for receiving notifications about Image information as the Image is constructed.", "name": "ImageObserver", "link": "ImageObserver"}, {"type": "Interface", "desc": "The interface for objects which can produce the image data for Images.", "name": "ImageProducer", "link": "ImageProducer"}, {"type": "Interface", "desc": "This interface describes single-input/single-output operations performed on Raster objects.", "name": "RasterOp", "link": "RasterOp"}, {"type": "Interface", "desc": "RenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters.", "name": "RenderedImage", "link": "RenderedImage"}, {"type": "Interface", "desc": "An interface for objects that wish to be informed when tiles of a WritableRenderedImage become modifiable by some writer via a call to getWritableTile, and when they become unmodifiable via the last call to releaseWritableTile.", "name": "TileObserver", "link": "TileObserver"}, {"type": "Interface", "desc": "WriteableRenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters and which can be modified and/or written over.", "name": "WritableRenderedImage", "link": "WritableRenderedImage"}, {"type": "Class", "name": "AffineTransformOp", "link": "AffineTransformOp"}, {"type": "Class", "desc": "An ImageFilter class for scaling images using a simple area averaging algorithm that produces smoother results than the nearest neighbor algorithm.", "name": "AreaAveragingScaleFilter", "link": "AreaAveragingScaleFilter"}, {"type": "Class", "name": "BandCombineOp", "link": "BandCombineOp"}, {"type": "Class", "desc": "This class represents image data which is stored in a band interleaved  fashion and for  which each sample of a pixel occupies one data element of the DataBuffer.", "name": "BandedSampleModel", "link": "BandedSampleModel"}, {"type": "Class", "name": "BufferedImage", "link": "BufferedImage"}, {"type": "Class", "name": "BufferedImageFilter", "link": "BufferedImageFilter"}, {"type": "Class", "name": "BufferStrategy", "link": "BufferStrategy"}, {"type": "Class", "desc": "This class defines a lookup table object.", "name": "ByteLookupTable", "link": "ByteLookupTable"}, {"type": "Class", "desc": "This class performs a pixel-by-pixel color conversion of the data in the source image.", "name": "ColorConvertOp", "link": "ColorConvertOp"}, {"type": "Class", "name": "ColorModel", "link": "ColorModel"}, {"type": "Class", "name": "ComponentColorModel", "link": "ComponentColorModel"}, {"type": "Class", "desc": "This class represents image data which is stored such that each sample  of a pixel occupies one data element of the DataBuffer.", "name": "ComponentSampleModel", "link": "ComponentSampleModel"}, {"type": "Class", "desc": "This class implements a convolution from the source to the destination.", "name": "ConvolveOp", "link": "ConvolveOp"}, {"type": "Class", "desc": "An ImageFilter class for cropping images.", "name": "CropImageFilter", "link": "CropImageFilter"}, {"type": "Class", "desc": "This class exists to wrap one or more data arrays.", "name": "DataBuffer", "link": "DataBuffer"}, {"type": "Class", "name": "DataBufferByte", "link": "DataBufferByte"}, {"type": "Class", "name": "DataBufferDouble", "link": "DataBufferDouble"}, {"type": "Class", "name": "DataBufferFloat", "link": "DataBufferFloat"}, {"type": "Class", "name": "DataBufferInt", "link": "DataBufferInt"}, {"type": "Class", "name": "DataBufferShort", "link": "DataBufferShort"}, {"type": "Class", "name": "DataBufferUShort", "link": "DataBufferUShort"}, {"type": "Class", "name": "DirectColorModel", "link": "DirectColorModel"}, {"type": "Class", "desc": "This class is an implementation of the ImageProducer interface which takes an existing image and a filter object and uses them to produce image data for a new filtered version of the original image.", "name": "FilteredImageSource", "link": "FilteredImageSource"}, {"type": "Class", "desc": "This class implements a filter for the set of interface methods that are used to deliver data from an ImageProducer to an ImageConsumer.", "name": "ImageFilter", "link": "ImageFilter"}, {"type": "Class", "name": "IndexColorModel", "link": "IndexColorModel"}, {"type": "Class", "name": "Kernel", "link": "Kernel"}, {"type": "Class", "desc": "This class implements a lookup operation from the source to the destination.", "name": "LookupOp", "link": "LookupOp"}, {"type": "Class", "desc": "This abstract class defines a lookup table object.", "name": "LookupTable", "link": "LookupTable"}, {"type": "Class", "desc": "This class is an implementation of the ImageProducer interface which uses an array to produce pixel values for an Image.", "name": "MemoryImageSource", "link": "MemoryImageSource"}, {"type": "Class", "name": "MultiPixelPackedSampleModel", "link": "MultiPixelPackedSampleModel"}, {"type": "Class", "name": "PackedColorModel", "link": "PackedColorModel"}, {"type": "Class", "desc": "The PixelGrabber class implements an ImageConsumer which can be attached to an Image or ImageProducer object to retrieve a subset of the pixels in that image.", "name": "PixelGrabber", "link": "PixelGrabber"}, {"type": "Class", "desc": "This class represents image data which is stored in a pixel interleaved  fashion and for  which each sample of a pixel occupies one data element of the DataBuffer.", "name": "PixelInterleavedSampleModel", "link": "PixelInterleavedSampleModel"}, {"type": "Class", "desc": "A class representing a rectangular array of pixels.", "name": "Raster", "link": "Raster"}, {"type": "Class", "desc": "An ImageFilter class for scaling images using the simplest algorithm.", "name": "ReplicateScaleFilter", "link": "ReplicateScaleFilter"}, {"type": "Class", "desc": "This class performs a pixel-by-pixel rescaling of the data in the source image by multiplying the sample values for each pixel by a scale factor and then adding an offset.", "name": "RescaleOp", "link": "RescaleOp"}, {"type": "Class", "desc": "This class provides an easy way to create an ImageFilter which modifies the pixels of an image in the default RGB ColorModel.", "name": "RGBImageFilter", "link": "RGBImageFilter"}, {"type": "Class", "desc": "This abstract class defines an interface for extracting samples of pixels  in an image.", "name": "SampleModel", "link": "SampleModel"}, {"type": "Class", "desc": "This class defines a lookup table object.", "name": "ShortLookupTable", "link": "ShortLookupTable"}, {"type": "Class", "desc": "This class represents pixel data packed such that the N samples which make  up a single pixel are stored in a single data array element, and each data  data array element holds samples for only one pixel.", "name": "SinglePixelPackedSampleModel", "link": "SinglePixelPackedSampleModel"}, {"type": "Class", "desc": "VolatileImage is an image which can lose its contents at any time due to circumstances beyond the control of the application (e.g., situations caused by the operating system or by other applications).", "name": "VolatileImage", "link": "VolatileImage"}, {"type": "Class", "desc": "This class extends Raster to provide pixel writing capabilities.", "name": "WritableRaster", "link": "WritableRaster"}, {"type": "Exception", "name": "ImagingOpException", "link": "ImagingOpException"}, {"type": "Exception", "name": "RasterFormatException", "link": "RasterFormatException"}], "desc": "Provides classes for creating and modifying images. Images are processed using a streaming framework that involves an image producer, optional image filters, and an image consumer. This framework makes it possible to progressively render an image while it is being fetched and generated. Moreover, the framework allows an application to discard the storage used by an image and to regenerate it at any time. This package provides a number of image producers, consumers, and filters that you can configure for your image processing needs. "}