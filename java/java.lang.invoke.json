{"entries": [{"type": "Interface", "desc": "A symbolic reference obtained by cracking a direct method handle into its consitutent symbolic parts.", "name": "MethodHandleInfo", "link": "MethodHandleInfo"}, {"type": "Class", "name": "CallSite", "link": "CallSite"}, {"type": "Class", "name": "ConstantCallSite", "link": "ConstantCallSite"}, {"type": "Class", "name": "LambdaMetafactory", "link": "LambdaMetafactory"}, {"type": "Class", "desc": "A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.", "name": "MethodHandle", "link": "MethodHandle"}, {"type": "Class", "desc": "This class consists exclusively of static methods that help adapt method handles to other JVM types, such as interfaces.", "name": "MethodHandleProxies", "link": "MethodHandleProxies"}, {"type": "Class", "desc": "This class consists exclusively of static methods that operate on or return method handles.", "name": "MethodHandles", "link": "MethodHandles"}, {"type": "Class", "name": "MethodHandles.Lookup", "link": "MethodHandles.Lookup"}, {"type": "Class", "desc": "A method type represents the arguments and return type accepted and returned by a method handle, or the arguments and return type passed and expected by a method handle caller.", "name": "MethodType", "link": "MethodType"}, {"type": "Class", "name": "MutableCallSite", "link": "MutableCallSite"}, {"type": "Class", "desc": "Serialized form of a lambda expression.", "name": "SerializedLambda", "link": "SerializedLambda"}, {"type": "Class", "name": "SwitchPoint", "link": "SwitchPoint"}, {"type": "Class", "name": "VolatileCallSite", "link": "VolatileCallSite"}, {"type": "Exception", "desc": "LambdaConversionException", "name": "LambdaConversionException", "link": "LambdaConversionException"}, {"type": "Exception", "desc": "Thrown to indicate that code has attempted to call a method handle via the wrong method type.", "name": "WrongMethodTypeException", "link": "WrongMethodTypeException"}], "desc": "The java.lang.invoke package contains dynamic language support provided directly by the Java core class libraries and virtual machine.   As described in the Java Virtual Machine Specification, certain types in this package have special relations to dynamic language support in the virtual machine:  The class MethodHandle contains signature polymorphic methods which can be linked regardless of their type descriptor. Normally, method linkage requires exact matching of type descriptors.  The JVM bytecode format supports immediate constants of the classes MethodHandle and MethodType.  Summary of relevant Java Virtual Machine changes The following low-level information summarizes relevant parts of the Java Virtual Machine specification. For full details, please see the current version of that specification.  Each occurrence of an invokedynamic instruction is called a dynamic call site. invokedynamic instructions A dynamic call site is originally in an unlinked state. In this state, there is no target method for the call site to invoke.  Before the JVM can execute a dynamic call site (an invokedynamic instruction), the call site must first be linked. Linking is accomplished by calling a bootstrap method which is given the static information content of the call site, and which must produce a method handle that gives the behavior of the call site.  Each invokedynamic instruction statically specifies its own bootstrap method as a constant pool reference. The constant pool reference also specifies the call site's name and type descriptor, just like invokevirtual and the other invoke instructions.  Linking starts with resolving the constant pool entry for the bootstrap method, and resolving a MethodType object for the type descriptor of the dynamic call site. This resolution process may trigger class loading. It may therefore throw an error if a class fails to load. This error becomes the abnormal termination of the dynamic call site execution. Linkage does not trigger class initialization.  The bootstrap method is invoked on at least three values:  a MethodHandles.Lookup, a lookup object on the caller class in which dynamic call site occurs a String, the method name mentioned in the call site a MethodType, the resolved type descriptor of the call optionally, between 1 and 251 additional static arguments taken from the constant pool  Invocation is as if by MethodHandle.invoke. The returned result must be a CallSite (or a subclass). The type of the call site's target must be exactly equal to the type derived from the dynamic call site's type descriptor and passed to the bootstrap method. The call site then becomes permanently linked to the dynamic call site.  As documented in the JVM specification, all failures arising from the linkage of a dynamic call site are reported by a BootstrapMethodError, which is thrown as the abnormal termination of the dynamic call site execution. If this happens, the same error will the thrown for all subsequent attempts to execute the dynamic call site.  timing of linkage A dynamic call site is linked just before its first execution. The bootstrap method call implementing the linkage occurs within a thread that is attempting a first execution.  If there are several such threads, the bootstrap method may be invoked in several threads concurrently. Therefore, bootstrap methods which access global application data must take the usual precautions against race conditions. In any case, every invokedynamic instruction is either unlinked or linked to a unique CallSite object.  In an application which requires dynamic call sites with individually mutable behaviors, their bootstrap methods should produce distinct CallSite objects, one for each linkage request. Alternatively, an application can link a single CallSite object to several invokedynamic instructions, in which case a change to the target method will become visible at each of the instructions.  If several threads simultaneously execute a bootstrap method for a single dynamic call site, the JVM must choose one CallSite object and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored, and their dynamic call site invocations proceed with the originally chosen target object.  Discussion: These rules do not enable the JVM to duplicate dynamic call sites, or to issue \u201ccauseless\u201d bootstrap method calls. Every dynamic call site transitions at most once from unlinked to linked, just before its first invocation. There is no way to undo the effect of a completed bootstrap method call.  types of bootstrap methods As long as each bootstrap method can be correctly invoked by MethodHandle.invoke, its detailed type is arbitrary. For example, the first argument could be Object instead of MethodHandles.Lookup, and the return type could also be Object instead of CallSite. (Note that the types and number of the stacked arguments limit the legal kinds of bootstrap methods to appropriately typed static methods and constructors of CallSite subclasses.)  If a given invokedynamic instruction specifies no static arguments, the instruction's bootstrap method will be invoked on three arguments, conveying the instruction's caller class, name, and method type. If the invokedynamic instruction specifies one or more static arguments, those values will be passed as additional arguments to the method handle. (Note that because there is a limit of 255 arguments to any method, at most 251 extra arguments can be supplied, since the bootstrap method handle itself and its first three arguments must also be stacked.) The bootstrap method will be invoked as if by either MethodHandle.invoke or invokeWithArguments. (There is no way to tell the difference.)  The normal argument conversion rules for MethodHandle.invoke apply to all stacked arguments. For example, if a pushed value is a primitive type, it may be converted to a reference by boxing conversion. If the bootstrap method is a variable arity method (its modifier bit 0x0080 is set), then some or all of the arguments specified here may be collected into a trailing array parameter. (This is not a special rule, but rather a useful consequence of the interaction between CONSTANT_MethodHandle constants, the modifier bit for variable arity methods, and the asVarargsCollector transformation.)  Given these rules, here are examples of legal bootstrap method declarations, given various numbers N of extra arguments. The first rows (marked *) will work for any number of extra arguments.  Nsample bootstrap method *CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args) *CallSite bootstrap(Object... args) *CallSite bootstrap(Object caller, Object... nameAndTypeWithArgs) 0CallSite bootstrap(Lookup caller, String name, MethodType type) 0CallSite bootstrap(Lookup caller, Object... nameAndType) 1CallSite bootstrap(Lookup caller, String name, MethodType type, Object arg) 2CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args) 2CallSite bootstrap(Lookup caller, String name, MethodType type, String... args) 2CallSite bootstrap(Lookup caller, String name, MethodType type, String x, int y)  The last example assumes that the extra arguments are of type CONSTANT_String and CONSTANT_Integer, respectively. The second-to-last example assumes that all extra arguments are of type CONSTANT_String. The other examples work with all types of extra arguments.  As noted above, the actual method type of the bootstrap method can vary. For example, the fourth argument could be MethodHandle, if that is the type of the corresponding constant in the CONSTANT_InvokeDynamic entry. In that case, the MethodHandle.invoke call will pass the extra method handle constant as an Object, but the type matching machinery of MethodHandle.invoke will cast the reference back to MethodHandle before invoking the bootstrap method. (If a string constant were passed instead, by badly generated code, that cast would then fail, resulting in a BootstrapMethodError.)  Note that, as a consequence of the above rules, the bootstrap method may accept a primitive argument, if it can be represented by a constant pool entry. However, arguments of type boolean, byte, short, or char cannot be created for bootstrap methods, since such constants cannot be directly represented in the constant pool, and the invocation of the bootstrap method will not perform the necessary narrowing primitive conversions.  Extra bootstrap method arguments are intended to allow language implementors to safely and compactly encode metadata. In principle, the name and extra arguments are redundant, since each call site could be given its own unique bootstrap method. Such a practice is likely to produce large class files and constant pools."}