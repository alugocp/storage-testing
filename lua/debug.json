{"entries": [{"desc": "Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution. Note that commands for debug.debug are not lexically nested within any function and so have no direct access to local variables.", "name": "debug.debug ()", "type": "function"}, {"desc": "Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the debug.sethook function).", "name": "debug.gethook ([thread])", "type": "function"}, {"desc": "Returns a table with information about a function. You can give the function directly or you can give a number as the value of f, which means the function running at level f of the call stack of the given thread: level 0 is the current function (getinfo itself); level 1 is the function that called getinfo (except for tail calls, which do not count on the stack); and so on. If f is a number larger than the number of active functions, then getinfo returns nil. The returned table can contain all the fields returned by lua_getinfo, with the string what describing which fields to fill in. The default for what is to get all information available, except the table of valid lines. If present, the option 'f' adds a field named func with the function itself. If present, the option 'L' adds a field named activelines with the table of valid lines. For instance, the expression debug.getinfo(1,\"n\").name returns a name for the current function, if a reasonable name can be found, and the expression debug.getinfo(print) returns a table with all available information about the print function.", "name": "debug.getinfo ([thread,] f [, what])", "type": "function"}, {"desc": "This function returns the name and the value of the local variable with index local of the function at level f of the stack. This function accesses not only explicit local variables, but also parameters, temporaries, etc. The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Negative indices refer to vararg arguments; -1 is the first vararg argument. The function returns nil if there is no variable with the given index, and raises an error when called with a level out of range. (You can call debug.getinfo to check whether the level is valid.) Variable names starting with '(' (open parenthesis) represent variables with no known names (internal variables such as loop control variables, and variables from chunks saved without debug information). The parameter f may also be a function. In that case, getlocal returns only the name of function parameters.", "name": "debug.getlocal ([thread,] f, local)", "type": "function"}, {"desc": "Returns the metatable of the given value or nil if it does not have a metatable.", "name": "debug.getmetatable (value)", "type": "function"}, {"desc": "Returns the registry table (see \u00a74.5).", "name": "debug.getregistry ()", "type": "function"}, {"desc": "This function returns the name and the value of the upvalue with index up of the function f. The function returns nil if there is no upvalue with the given index. Variable names starting with '(' (open parenthesis) represent variables with no known names (variables from chunks saved without debug information).", "name": "debug.getupvalue (f, up)", "type": "function"}, {"desc": "Returns the Lua value associated to u. If u is not a full userdata, returns nil.", "name": "debug.getuservalue (u)", "type": "function"}, {"desc": "Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning: 'c': the hook is called every time Lua calls a function; 'r': the hook is called every time Lua returns from a function; 'l': the hook is called every time Lua enters a new line of code. Moreover, with a count different from zero, the hook is called also after every count instructions. When called without arguments, debug.sethook turns off the hook. When the hook is called, its first argument is a string describing the event that has triggered its call: \"call\" (or \"tail call\"), \"return\", \"line\", and \"count\". For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call getinfo with level 2 to get more information about the running function (level 0 is the getinfo function, and level 1 is the hook function).", "name": "debug.sethook ([thread,] hook, mask [, count])", "type": "function"}, {"desc": "This function assigns the value value to the local variable with index local of the function at level level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call getinfo to check whether the level is valid.) Otherwise, it returns the name of the local variable. See debug.getlocal for more information about variable indices and names.", "name": "debug.setlocal ([thread,] level, local, value)", "type": "function"}, {"desc": "Sets the metatable for the given value to the given table (which can be nil). Returns value.", "name": "debug.setmetatable (value, table)", "type": "function"}, {"desc": "This function assigns the value value to the upvalue with index up of the function f. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.", "name": "debug.setupvalue (f, up, value)", "type": "function"}, {"desc": "Sets the given value as the Lua value associated to the given udata. udata must be a full userdata. Returns udata.", "name": "debug.setuservalue (udata, value)", "type": "function"}, {"desc": "If message is present but is neither a string nor nil, this function returns message without further processing. Otherwise, it returns a string with a traceback of the call stack. The optional message string is appended at the beginning of the traceback. An optional level number tells at which level to start the traceback (default is 1, the function calling traceback).", "name": "debug.traceback ([thread,] [message [, level]])", "type": "function"}, {"desc": "Returns a unique identifier (as a light userdata) for the upvalue numbered n from the given function. These unique identifiers allow a program to check whether different closures share upvalues. Lua closures that share an upvalue (that is, that access a same external local variable) will return identical ids for those upvalue indices.", "name": "debug.upvalueid (f, n)", "type": "function"}, {"desc": "Make the n1-th upvalue of the Lua closure f1 refer to the n2-th upvalue of the Lua closure f2. 7 \u2013 Lua Standalone Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a standalone language. An interpreter for Lua as a standalone language, called simply lua, is provided with the standard distribution. The standalone interpreter includes all standard libraries, including the debug library. Its usage is: lua [options] [script [args]] The options are: -e stat: executes string stat; -l mod: \"requires\" mod and assigns the result to global @mod; -i: enters interactive mode after running script; -v: prints version information; -E: ignores environment variables; --: stops handling options; -: executes stdin as a file and stops handling options. After handling its options, lua runs the given script. When called without arguments, lua behaves as lua -v -i when the standard input (stdin) is a terminal, and as lua - otherwise. When called without option -E, the interpreter checks for an environment variable LUA_INIT_5_3 (or LUA_INIT if the versioned name is not defined) before running any argument. If the variable content has the format @filename, then lua executes the file. Otherwise, lua executes the string itself. When called with option -E, besides ignoring LUA_INIT, Lua also ignores the values of LUA_PATH and LUA_CPATH, setting the values of package.path and package.cpath with the default paths defined in luaconf.h. All options are handled in order, except -i and -E. For instance, an invocation like $ lua -e'a=1' -e 'print(a)' script.lua will first set a to 1, then print the value of a, and finally run the file script.lua with no arguments. (Here $ is the shell prompt. Your prompt may be different.) Before running any code, lua collects all command-line arguments in a global table called arg. The script name goes to index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus its options) go to negative indices. For instance, in the call $ lua -la b.lua t1 t2 the table is like this: arg = { [-2] = \"lua\", [-1] = \"-la\", [0] = \"b.lua\", [1] = \"t1\", [2] = \"t2\" } If there is no script in the call, the interpreter name goes to index 0, followed by the other arguments. For instance, the call $ lua -e \"print(arg[1])\" will print \"-e\". If there is a script, the script is called with arguments arg[1], \u00b7\u00b7\u00b7, arg[#arg]. (Like all chunks in Lua, the script is compiled as a vararg function.) In interactive mode, Lua repeatedly prompts and waits for a line. After reading a line, Lua first try to interpret the line as an expression. If it succeeds, it prints its value. Otherwise, it interprets the line as a statement. If you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt. If the global variable _PROMPT contains a string, then its value is used as the prompt. Similarly, if the global variable _PROMPT2 contains a string, its value is used as the secondary prompt (issued during incomplete statements). In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is not a string but has a metamethod __tostring, the interpreter calls this metamethod to produce the final message. Otherwise, the interpreter converts the error object to a string and adds a stack traceback to it. When finishing normally, the interpreter closes its main Lua state (see lua_close). The script can avoid this step by calling os.exit to terminate. To allow the use of Lua as a script interpreter in Unix systems, the standalone interpreter skips the first line of a chunk if it starts with #. Therefore, Lua scripts can be made into executable programs by using chmod +x and the #! form, as in #!/usr/local/bin/lua (Of course, the location of the Lua interpreter may be different in your machine. If lua is in your PATH, then #!/usr/bin/env lua is a more portable solution.) 8 \u2013 Incompatibilities with the Previous Version Here we list the incompatibilities that you may find when moving a program from Lua 5.2 to Lua 5.3. You can avoid some incompatibilities by compiling Lua with appropriate options (see file luaconf.h). However, all these compatibility options will be removed in the future. Lua versions can always change the C API in ways that do not imply source-code changes in a program, such as the numeric values for constants or the implementation of functions as macros. Therefore, you should not assume that binaries are compatible between different Lua versions. Always recompile clients of the Lua API when using a new version. Similarly, Lua versions can always change the internal representation of precompiled chunks; precompiled chunks are not compatible between different Lua versions. The standard paths in the official distribution may change between versions.", "name": "debug.upvaluejoin (f1, n1, f2, n2)", "type": "function"}]}