{"entries": [{"type": "public class method", "name": "new(specs)", "desc": ""}, {"type": "public instance method", "name": "<<(spec)", "desc": ""}, {"type": "public instance method", "name": "[](key)", "desc": ""}, {"type": "public instance method", "name": "[]=(key, value)", "desc": ""}, {"type": "public instance method", "name": "each(&b)", "desc": ""}, {"type": "public instance method", "name": "empty?()", "desc": ""}, {"type": "public instance method", "name": "find_by_name_and_platform(name, platform)", "desc": ""}, {"type": "public instance method", "name": "for(dependencies, skip = [], check = false, match_current_platform = false, raise_on_missing = true)", "desc": ""}, {"type": "public instance method", "name": "length()", "desc": ""}, {"type": "public instance method", "name": "materialize(deps, missing_specs = nil)", "desc": ""}, {"type": "public instance method", "name": "materialized_for_all_platforms()", "desc": "Materialize for all the specs in the spec set, regardless of what platform they're for This is in contrast to how for does platform filtering (and specifically different from how `materialize` calls `for` only for the current platform) @return [Array<Gem::Specification>]"}, {"type": "public instance method", "name": "merge(set)", "desc": ""}, {"type": "public instance method", "name": "size()", "desc": ""}, {"type": "public instance method", "name": "sort!()", "desc": ""}, {"type": "public instance method", "name": "to_a()", "desc": ""}, {"type": "public instance method", "name": "to_hash()", "desc": ""}, {"type": "public instance method", "name": "valid_for?(deps)", "desc": ""}, {"type": "public instance method", "name": "what_required(spec)", "desc": ""}]}