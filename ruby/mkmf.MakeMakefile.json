{"entries": [{"type": "constant", "name": "ASSEMBLE_C", "desc": "Command which will translate C files to assembler sources in the generated\nMakefile"}, {"type": "constant", "name": "ASSEMBLE_CXX", "desc": "Command which will translate C++ files to assembler sources in the\ngenerated Makefile"}, {"type": "constant", "name": "CLEANINGS", "desc": "Makefile rules that will clean the extension build directory"}, {"type": "constant", "name": "COMMON_HEADERS", "desc": "Common headers for Ruby C extensions"}, {"type": "constant", "name": "COMMON_LIBS", "desc": "Common libraries for Ruby C extensions"}, {"type": "constant", "name": "COMPILE_C", "desc": "Command which will compile C files in the generated Makefile"}, {"type": "constant", "name": "COMPILE_CXX", "desc": "Command which will compile C++ files in the generated Makefile"}, {"type": "constant", "name": "COMPILE_RULES", "desc": "make compile rules"}, {"type": "constant", "name": "CONFIG", "desc": "The makefile configuration using the defaults from when Ruby was built."}, {"type": "constant", "name": "CONFTEST_CXX", "desc": ""}, {"type": "constant", "name": "CXX_EXT", "desc": "Extensions for files complied with a C++ compiler"}, {"type": "constant", "name": "C_EXT", "desc": "Extensions for files compiled with a C compiler"}, {"type": "constant", "name": "EXPORT_PREFIX", "desc": ""}, {"type": "constant", "name": "HDR_EXT", "desc": "Extensions for header files"}, {"type": "constant", "name": "LIBARG", "desc": "Argument which will add a library to the linker"}, {"type": "constant", "name": "LIBPATHFLAG", "desc": "Argument which will add a library path to the linker"}, {"type": "constant", "name": "LINK_SO", "desc": "Command which will link a shared library"}, {"type": "constant", "name": "MAIN_DOES_NOTHING", "desc": "A C main function which does no work"}, {"type": "constant", "name": "ORIG_LIBPATH", "desc": ""}, {"type": "constant", "name": "RPATHFLAG", "desc": ""}, {"type": "constant", "name": "RULE_SUBST", "desc": ""}, {"type": "constant", "name": "SRC_EXT", "desc": "Extensions for source files"}, {"type": "constant", "name": "TRY_LINK", "desc": "Command which will compile a program in order to test linking a library"}, {"type": "constant", "name": "TRY_LINK_CXX", "desc": ""}, {"type": "constant", "name": "UNIVERSAL_INTS", "desc": ""}, {"type": "public instance method", "name": "check_signedness(type, headers = nil, opts = nil, &b)", "desc": "Returns the signedness of the given type.  You may optionally specify additional headers to search in for the type."}, {"type": "public instance method", "name": "check_sizeof(type, headers = nil, opts = \"\", &b)", "desc": "Returns the size of the given type.  You may optionally specify additional headers to search in for the type."}, {"type": "public instance method", "name": "convertible_int(type, headers = nil, opts = nil, &b)", "desc": "Returns the convertible integer type of the given type.  You may optionally specify additional headers to search in for the type. convertible means actually the same type, or typedef'd from the same type."}, {"type": "public instance method", "name": "create_header(header = \"extconf.h\")", "desc": "Generates a header file consisting of the various macro definitions generated by other methods such as #have_func and have_header. These are then wrapped in a custom #ifndef based on the header file name, which defaults to \u201cextconf.h\u201d."}, {"type": "public instance method", "name": "create_makefile(target, srcprefix = nil)", "desc": "Generates the Makefile for your extension, passing along any options and preprocessor constants that you may have generated through other methods."}, {"type": "public instance method", "name": "depend_rules(depend)", "desc": "Processes the data contents of the \u201cdepend\u201d file.  Each line of this file is expected to be a file name."}, {"type": "public instance method", "name": "dir_config(target)click to toggle source", "desc": ""}, {"type": "public instance method", "name": "dummy_makefile(srcdir)", "desc": "creates a stub Makefile."}, {"type": "public instance method", "name": "enable_config(config, default=nil)", "desc": "Tests for the presence of an --enable-config or --disable-config option. Returns true if the enable option is given, false if the disable option is given, and the default value otherwise."}, {"type": "public instance method", "name": "find_executable(bin, path = nil)", "desc": "Searches for the executable bin on path.  The default path is your PATH environment variable. If that isn't defined, it will resort to searching /usr/local/bin, /usr/ucb, /usr/bin and /bin."}, {"type": "public instance method", "name": "find_header(header, *paths)", "desc": "Instructs mkmf to search for the given header in any of the paths provided, and returns whether or not it was found in those paths."}, {"type": "public instance method", "name": "find_library(lib, func, *paths, &b)", "desc": "Returns whether or not the entry point func can be found within the library lib in one of the paths specified, where paths is an array of strings.  If func is nil , then the main() function is used as the entry point."}, {"type": "public instance method", "name": "find_type(type, opt, *headers, &b)", "desc": "Returns where the static type type is defined."}, {"type": "public instance method", "name": "have_const(const, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not the constant const is defined.  You may optionally pass the type of const as [const, type], such as:"}, {"type": "public instance method", "name": "have_framework(fw, &b)", "desc": "Returns whether or not the given framework can be found on your system. If found, a macro is passed as a preprocessor constant to the compiler using the framework name, in uppercase, prepended with HAVE_FRAMEWORK_."}, {"type": "public instance method", "name": "have_func(func, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not the function func can be found in the common header files, or within any headers that you provide.  If found, a macro is passed as a preprocessor constant to the compiler using the function name, in uppercase, prepended with HAVE_."}, {"type": "public instance method", "name": "have_header(header, preheaders = nil, opt = \"\", &b)", "desc": "Returns whether or not the given header file can be found on your system. If found, a macro is passed as a preprocessor constant to the compiler using the header file name, in uppercase, prepended with HAVE_."}, {"type": "public instance method", "name": "have_library(lib, func = nil, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not the given entry point func can be found within lib.  If func is nil, the main() entry point is used by default.  If found, it adds the library to list of libraries to be used when linking your extension."}, {"type": "public instance method", "name": "have_macro(macro, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not macro is defined either in the common header files or within any headers you provide."}, {"type": "public instance method", "name": "have_struct_member(type, member, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not the struct of type type contains member.  If it does not, or the struct type can't be found, then false is returned. You may optionally specify additional headers in which to look for the struct (in addition to the common header files)."}, {"type": "public instance method", "name": "have_type(type, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not the static type type is defined.  You may optionally pass additional headers to check against in addition to the common header files."}, {"type": "public instance method", "name": "have_var(var, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not the variable var can be found in the common header files, or within any headers that you provide.  If found, a macro is passed as a preprocessor constant to the compiler using the variable name, in uppercase, prepended with HAVE_."}, {"type": "public instance method", "name": "pkg_config(pkg, option=nil)", "desc": "Returns compile/link information about an installed library in a tuple of [cflags, ldflags, libs], by using the command found first in the following commands:"}, {"type": "public instance method", "name": "try_const(const, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not the constant const is defined."}, {"type": "public instance method", "name": "try_type(type, headers = nil, opt = \"\", &b)", "desc": "Returns whether or not the static type type is defined."}, {"type": "public instance method", "name": "with_config(config, default=nil)", "desc": "Tests for the presence of a --with-config or --without-config option.  Returns true if the with option is given, false if the without option is given, and the default value otherwise."}]}