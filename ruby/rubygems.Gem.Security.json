{"entries": [{"type": "constant", "name": "AlmostNoSecurity", "desc": "AlmostNo security policy: only verify that the signing certificate is the\none that actually signed the data.  Make no attempt to verify the signing\ncertificate chain.\nThis policy is basically useless. better than nothing, but can still be\neasily spoofed, and is not recommended."}, {"type": "constant", "name": "DIGEST_ALGORITHM", "desc": "Digest algorithm used to sign gems"}, {"type": "constant", "name": "EXTENSIONS", "desc": "The default set of extensions are:\n\nThe certificate is not a certificate authority\n\nThe key for the certificate may be used for key and data encipherment and\ndigital signatures\n\nThe certificate contains a subject key identifier\n"}, {"type": "constant", "name": "HighSecurity", "desc": "High security policy: only allow signed gems to be installed, verify the\nsigning certificate, verify the signing certificate chain all the way to\nthe root certificate, and only trust root certificates that we have\nexplicitly allowed trust for.\nThis security policy is significantly more difficult to bypass, and offers\na reasonable guarantee that the contents of the gem have not been altered."}, {"type": "constant", "name": "KEY_ALGORITHM", "desc": "Algorithm for creating the key pair used to sign gems"}, {"type": "constant", "name": "KEY_CIPHER", "desc": "Cipher used to encrypt the key pair used to sign gems. Must be in the list\nreturned by OpenSSL::Cipher.ciphers"}, {"type": "constant", "name": "KEY_LENGTH", "desc": "Length of keys created by KEY_ALGORITHM"}, {"type": "constant", "name": "LowSecurity", "desc": "Low security policy: only verify that the signing certificate is actually\nthe gem signer, and that the signing certificate is valid.\nThis policy is better than nothing, but can still be easily spoofed, and is\nnot recommended."}, {"type": "constant", "name": "MediumSecurity", "desc": "Medium security policy: verify the signing certificate, verify the signing\ncertificate chain all the way to the root certificate, and only trust root\ncertificates that we have explicitly allowed trust for.\nThis security policy is reasonable, but it allows unsigned packages, so a\nmalicious person could simply delete the package signature and pass the gem\noff as unsigned."}, {"type": "constant", "name": "NoSecurity", "desc": "No security policy: all package signature checks are disabled."}, {"type": "constant", "name": "ONE_DAY", "desc": "One day in seconds"}, {"type": "constant", "name": "ONE_YEAR", "desc": "One year in seconds"}, {"type": "constant", "name": "Policies", "desc": "Hash of configured security policies"}, {"type": "constant", "name": "SigningPolicy", "desc": "Policy used to verify a certificate and\nkey when signing a gem"}, {"type": "public class method", "name": "alt_name_or_x509_entry(certificate, x509_entry)", "desc": ""}, {"type": "public class method", "name": "create_cert(subject, key, age = ONE_YEAR, extensions = EXTENSIONS, serial = 1)", "desc": "Creates an unsigned certificate for subject and key.  The lifetime of the key is from the current time to age which defaults to one year."}, {"type": "public class method", "name": "create_cert_email(email, key, age = ONE_YEAR, extensions = EXTENSIONS)", "desc": "Creates a self-signed certificate with an issuer and subject from email, a subject alternative name of email and the given extensions for the key."}, {"type": "public class method", "name": "create_cert_self_signed(subject, key, age = ONE_YEAR, extensions = EXTENSIONS, serial = 1)", "desc": "Creates a self-signed certificate with an issuer and subject of subject and the given extensions for the key."}, {"type": "public class method", "name": "create_key(length = KEY_LENGTH, algorithm = KEY_ALGORITHM)", "desc": "Creates a new key pair of the specified length and algorithm.  The default is a 3072 bit RSA key."}, {"type": "public class method", "name": "email_to_name(email_address)", "desc": "Turns email_address into an OpenSSL::X509::Name"}, {"type": "public class method", "name": "re_sign(expired_certificate, private_key, age = ONE_YEAR, extensions = EXTENSIONS)", "desc": "Signs expired_certificate with private_key if the keys match and the expired certificate was self-signed."}, {"type": "public class method", "name": "reset()", "desc": "Resets the trust directory for verifying gems."}, {"type": "public class method", "name": "sign(certificate, signing_key, signing_cert, age = ONE_YEAR, extensions = EXTENSIONS, serial = 1)", "desc": "Sign the public key from certificate with the signing_key and signing_cert, using the Gem::Security::DIGEST_ALGORITHM.  Uses the default certificate validity range and extensions."}, {"type": "public class method", "name": "trust_dir()", "desc": "Returns a Gem::Security::TrustDir which wraps the directory where trusted certificates live."}, {"type": "public class method", "name": "trusted_certificates(&block)", "desc": "Enumerates the trusted certificates via Gem::Security::TrustDir."}, {"type": "public class method", "name": "write(pemmable, path, permissions = 0600, passphrase = nil, cipher = KEY_CIPHER)", "desc": "Writes pemmable, which must respond to to_pem to path with the given permissions. If passed cipher and passphrase those arguments will be passed to to_pem."}]}